"""
Static Pydantic code generator from SQLAlchemy models

Generates actual Python code (not runtime models) for full IDE type support.

Usage:
    python -m src.utils.codegen generate
    # Or via CLI:
    uv run codegen generate
"""

import sys
from pathlib import Path
from typing import Type, Set, Optional, List, Tuple
from sqlalchemy import Integer, String, DateTime, Numeric, Boolean, Float
from sqlalchemy.orm import DeclarativeMeta
from sqlalchemy.inspection import inspect
from datetime import datetime
from decimal import Decimal


def generate_pydantic_code(
    db_model: Type[DeclarativeMeta],
    *,
    class_name: Optional[str] = None,
    exclude: Optional[Set[str]] = None,
    include_cdc_fields: bool = False,
) -> str:
    """
    Generate Pydantic model code as a string.
    
    Args:
        db_model: SQLAlchemy model class
        class_name: Name for the Pydantic class
        exclude: Fields to exclude (relationships, auto-fields, etc.)
        include_cdc_fields: Add CDC fields (is_deleted, lsn)
    
    Returns:
        Python code string for the Pydantic model
    """
    exclude = exclude or set()
    mapper = inspect(db_model)
    class_name = class_name or db_model.__name__
    
    # Collect field definitions
    field_lines = []
    imports = {"from pydantic import BaseModel, Field", "from datetime import datetime"}
    
    for column in mapper.columns:
        if column.name in exclude:
            continue
        
        # Map SQLAlchemy type to Python type
        py_type, type_import = _map_type_to_string(column.type)
        if type_import:
            imports.add(type_import)
        
        # Handle nullable
        if column.nullable:
            py_type = f"{py_type} | None"
            default = " = None"
        else:
            default = ""
        
        # Add Field constraints
        field_constraints = []
        if isinstance(column.type, String) and column.type.length:
            field_constraints.append(f"max_length={column.type.length}")
        if isinstance(column.type, Numeric):
            if column.type.scale:
                field_constraints.append(f"decimal_places={column.type.scale}")
        
        if field_constraints:
            field_def = f"    {column.name}: {py_type} = Field({', '.join(field_constraints)})"
        else:
            field_def = f"    {column.name}: {py_type}{default}"
        
        field_lines.append(field_def)
    
    # Add CDC fields if requested
    if include_cdc_fields:
        field_lines.append("    is_deleted: int = Field(ge=0, le=1)  # UInt8")
        field_lines.append("    lsn: int  # UInt64")
    
    # Build class code
    imports_str = "\n".join(sorted(imports))
    fields_str = "\n".join(field_lines)
    
    docstring = f'    """Generated from SQLAlchemy model: {db_model.__name__}"""'
    
    code = f'''
{imports_str}


class {class_name}(BaseModel):
{docstring}
{fields_str}
'''.strip()
    
    return code


def _map_type_to_string(column_type) -> Tuple[str, Optional[str]]:
    """
    Map SQLAlchemy type to Python type string and required import.
    
    Returns:
        (type_string, import_statement_or_none)
    """
    if isinstance(column_type, Integer):
        return "int", None
    elif isinstance(column_type, String):
        return "str", None
    elif isinstance(column_type, DateTime):
        return "datetime", "from datetime import datetime"
    elif isinstance(column_type, Numeric):
        return "Decimal", "from decimal import Decimal"
    elif isinstance(column_type, Float):
        return "float", None
    elif isinstance(column_type, Boolean):
        return "bool", None
    else:
        return "str", None


def generate_all_schemas() -> str:
    """Generate complete schemas.py file with all models"""
    from ..models import Customer, Product, Order, OrderItem
    
    # Header
    header = '''"""
Auto-generated Pydantic schemas from SQLAlchemy models

Generated by: src/utils/codegen.py
DO NOT EDIT MANUALLY - Run `python -m src.utils.codegen generate` to regenerate

These schemas provide:
- Full IDE type hints and autocomplete
- Moose OLAP compatibility
- Pydantic validation
"""

from pydantic import BaseModel, Field
from datetime import datetime
from decimal import Decimal
from typing import Literal


# ==================== Base Schemas (OLTP) ====================
'''
    
    # Generate base schemas (exclude relationships)
    models = [
        (Customer, {"orders"}),
        (Product, {"order_items"}),
        (Order, {"customer", "items"}),
        (OrderItem, {"order", "product"}),
    ]
    
    base_schemas = []
    for model, exclude_rels in models:
        code = generate_pydantic_code(
            model,
            class_name=model.__name__,
            exclude=exclude_rels
        )
        # Remove imports (already in header)
        code_lines = code.split('\n')
        code_without_imports = '\n'.join([
            line for line in code_lines 
            if not line.startswith('from') and not line.startswith('import')
        ]).strip()
        base_schemas.append(code_without_imports)
    
    # CDC metadata types
    cdc_section = '''

# ==================== CDC Metadata ====================

class CdcMetadata(BaseModel):
    """Redpanda Connect CDC metadata"""
    table: str
    operation: Literal["delete", "insert", "update", "read"]
    lsn: str  # PostgreSQL LSN as hex string


class CdcFields(BaseModel):
    """ClickHouse CDC tracking fields"""
    is_deleted: int = Field(ge=0, le=1)  # UInt8
    lsn: int  # UInt64


# ==================== Dimension Tables (OLAP) ====================
'''
    
    # Generate OLAP schemas with CDC fields
    olap_schemas = []
    for model, exclude_rels in models:
        base_name = model.__name__
        olap_name = f"{base_name}Dimension" if base_name != "OrderItem" else "OrderItemFact"
        
        # Use inheritance for cleaner code
        olap_class = f'''
class {olap_name}({base_name}, CdcFields):
    """OLAP dimension/fact for {base_name} with CDC tracking"""
    pass
'''.strip()
        olap_schemas.append(olap_class)
    
    # Combine everything
    full_code = (
        header + 
        "\n\n".join(base_schemas) +
        cdc_section +
        "\n\n".join(olap_schemas) +
        "\n"
    )
    
    return full_code


def main():
    """CLI entry point"""
    if len(sys.argv) < 2 or sys.argv[1] != "generate":
        print("Usage: python -m src.utils.codegen generate")
        sys.exit(1)
    
    print("ðŸ”§ Generating Pydantic schemas from SQLAlchemy models...")
    
    try:
        code = generate_all_schemas()
        
        # Write to schemas.py
        output_path = Path(__file__).parent.parent / "schemas.py"
        output_path.write_text(code)
        
        print(f"âœ… Generated schemas written to: {output_path}")
        print(f"ðŸ“Š Total lines: {len(code.splitlines())}")
        print("\nðŸ’¡ Your schemas now have full type hints!")
        
    except Exception as e:
        print(f"âŒ Error generating schemas: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

